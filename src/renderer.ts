import { App, TFile, MarkdownRenderer, Component } from "obsidian";
import { applyFilterChain } from "./filters";

export async function renderTemplate(
	app: App,
	template: string,
	file: TFile,
	container: HTMLElement,
	component: Component
) {
	const cache = app.metadataCache.getFileCache(file);
	const frontmatter = cache?.frontmatter;
	const rawContent = await app.vault.read(file);

	// 1. Extract Body Content
	let bodyContent = rawContent;
	if (frontmatter && frontmatter.position) {
		bodyContent = rawContent.substring(frontmatter.position.end.offset).trim();
	}

	// 2. Prepare Queues
	const markdownQueue: { id: string, content: string }[] = [];
	const contentPlaceholderId = `custom-view-content-${Date.now()}`;

	// 3. Helper to resolve raw value
	const resolveValue = (key: string, index?: string): any => {
		let value: any;
		if (key === "name") value = file.name;
		else if (key === "basename") value = file.basename;
		else if (key === "size") value = file.stat.size;
		else if (key === "ctime") value = file.stat.ctime; // Timestamp for dates
		else if (key === "mtime") value = file.stat.mtime;
		else if (frontmatter && frontmatter[key] !== undefined) value = frontmatter[key];
		else return null;

		if (index !== undefined && Array.isArray(value)) {
			const i = parseInt(index);
			return i < value.length ? value[i] : "";
		}
		return value;
	};

	// 4. Process Template with Filters
	// Regex breakdown:
	// {{ file.KEY ( [INDEX] )? ( | FILTER_CHAIN )? }}
	const regex = /\{\{file\.([a-zA-Z0-9_.-]+)(\[(\d+)\])?(?:\s*\|(.*?))?\}\}/g;

	const filledTemplate = template.replace(
		regex,
		(match, key, _, index, filterChain, offset, fullString) => {

			// SPECIAL CASE: The Content
			if (key === "content") {
				return `<div id="${contentPlaceholderId}" class="markdown-rendered-content"></div>`;
			}

			// 1. Get Base Value
			let value = resolveValue(key, index);
			if (value === null) return "";

			// 2. Apply Filters (NEW)
			if (filterChain) {
				value = applyFilterChain(value, filterChain.trim());
			}

			// 3. Context Check (Inside Attribute or Body?)
			const prefix = fullString.substring(0, offset);
			const doubleQuotes = (prefix.match(/"/g) || []).length;
			const singleQuotes = (prefix.match(/'/g) || []).length;
			const isInsideAttribute = (doubleQuotes % 2 !== 0) || (singleQuotes % 2 !== 0);

			// 4. Return Output
			if (isInsideAttribute) {
				// Return RAW string (for href="", src="")
				return String(value);
			} else {
				// Return PLACEHOLDER (Render as Markdown)
				// We assume if it's in the body, it might contain Markdown syntax (like [[Links]] generated by filters)
				const placeholderId = `cv-md-${markdownQueue.length}-${Date.now()}`;
				markdownQueue.push({ id: placeholderId, content: String(value) });
				return `<span id="${placeholderId}"></span>`;
			}
		}
	);

	// 5. Inject HTML
	container.innerHTML = filledTemplate;

	// 6. Render Markdown Queue
	for (const item of markdownQueue) {
		const span = container.querySelector(`#${item.id}`) as HTMLElement;
		if (span) {
			await MarkdownRenderer.render(app, item.content, span, file.path, component);
			span.removeAttribute("id");

			// Cleanup wrapping <p> if strictly wrapping
			const p = span.querySelector("p");
			if (p && p.parentElement === span && span.children.length === 1) {
				p.replaceWith(...Array.from(p.childNodes));
			}
		}
	}

	// 7. Render Body Content
	const contentEl = container.querySelector(`#${contentPlaceholderId}`) as HTMLElement;
	if (contentEl) {
		// Create the proper reading mode structure
		const sizer = document.createElement("div");
		sizer.addClass("markdown-preview-sizer");
		sizer.addClass("markdown-preview-section");
		contentEl.appendChild(sizer);

		await MarkdownRenderer.render(app, bodyContent, sizer, file.path, component);
		contentEl.removeAttribute("id");
	}

	// 8. Execute Scripts
	// Scripts in innerHTML are not executed automatically for security reasons.
	// We manually extract and execute them to allow dynamic behavior in templates.
	executeScripts(container);
}

/**
 * Executes all script tags found in the container.
 * Scripts are executed in order and can access the fully rendered DOM.
 * This function handles both inline scripts and external scripts (with src attribute).
 * Inline scripts are wrapped in an IIFE to prevent variable redeclaration errors on re-renders.
 */
function executeScripts(container: HTMLElement): void {
	const scripts = Array.from(container.querySelectorAll('script'));

	scripts.forEach((oldScript) => {
		const newScript = document.createElement('script');

		// Copy all attributes from the original script
		Array.from(oldScript.attributes).forEach((attr) => {
			newScript.setAttribute(attr.name, attr.value);
		});

		// Handle inline scripts (textContent)
		if (oldScript.textContent) {
			const scriptContent = oldScript.textContent.trim();
			if (scriptContent) {
				// Wrap script content in IIFE to create a new scope
				// This prevents "Identifier has already been declared" errors on re-renders
				newScript.textContent = `(function() {\n${scriptContent}\n})();`;
			}
		}

		// Handle external scripts (src attribute)
		if (oldScript.src && !oldScript.textContent) {
			newScript.src = oldScript.src;
		}

		// Insert the new script before the old one, then remove the old one
		// This ensures scripts execute in order
		oldScript.parentNode?.insertBefore(newScript, oldScript);
		oldScript.remove();
	});
}
